using System.Diagnostics.CodeAnalysis;
using ThemModdingHerds.Models.Utils;
using ThemModdingHerds.Models.Wavefront;

namespace ThemModdingHerds.Models;
public class WavefrontModel(IEnumerable<Vertex> vertices,IEnumerable<Face> indices) : Model(vertices,indices), IParsable<WavefrontModel>
{
    public const string HEADER = "# This file was generated by ThemModdingHerds.Models library\n# https://github.com/ThemModdingHerds/levels\n";
    public MTL.Material? Material {get;set;}
    public bool Shading {get;set;} = false;
    public WavefrontModel(Model model): this(model.Vertices,model.Faces)
    {

    }
    public WavefrontModel(): this([],[])
    {

    }
    public static WavefrontModel Parse(string s,IFormatProvider? provider)
    {
        string[] lines = Strings.RemoveComments(s).Split('\n');
        List<Vertex> vertices = [];
        List<Face> indices = [];
        List<string> vs = [];
        List<string> vts = [];
        List<string> vns = [];
        foreach(string line in lines)
        {
            if(line.StartsWith("f "))
                indices.Add(WavefrontFace.Parse(line));
            if(line.StartsWith("v "))
                vs.Add(line);
            if(line.StartsWith("vt "))
                vts.Add(line);
            if(line.StartsWith("vn "))
                vns.Add(line);
        }
        for(int i = 0;i < vs.Count;i++)
        {
            WavefrontVertex vertex = new()
            {
                PositionString = vs[i],
            };
            if(i < vts.Count)
                vertex.UVString = vts[i];
            if(i < vns.Count)
                vertex.NormalString = vns[i];
            vertices.Add(vertex);
        }
        return new(vertices,indices);
    }
    public static WavefrontModel Parse(string s) => Parse(s,null);
    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out WavefrontModel result)
    {
        result = null;
        try
        {
            if(s == null) throw new Exception();
            result = Parse(s,provider);
            return true;
        }
        catch(Exception)
        {
            return false;
        }
    }
    public static bool TryParse([NotNullWhen(true)] string? s,[MaybeNullWhen(false)] out WavefrontModel result) => TryParse(s,null,out result);
    public string ToString(string name,string? mat_path)
    {
        return string.Join('\n',[
            HEADER,
            Material != null && mat_path != null ? $"mtllib {mat_path}" : string.Empty,
            $"o {name}",
            ToVerticesString(),
            ToNormalsString(),
            ToUVsString(),
            $"s {(Shading ? "1" : "0")}",
            Material != null && mat_path != null ? $"usemtl {Material.Name}" : string.Empty,
            ToFacesString()
        ]);
    }
    public string ToString(string name) => ToString(name,null);
    public override string ToString() => ToString("<Object-Name>","<Material-Path>");
    public string ToVerticesString()
    {
        return string.Join('\n',from vertex in Vertices select ToPositionString(vertex));
    }
    public string ToUVsString()
    {
        return string.Join('\n',from vertex in Vertices select ToUVString(vertex));
    }
    public string ToNormalsString()
    {
        return string.Join('\n',from vertex in Vertices select ToNormalString(vertex));
    }
    public string ToFacesString()
    {
        return string.Join('\n',from face in Faces select ToFaceString(face));
    }
    public void Save(string filepath)
    {
        File.WriteAllText(filepath,ToString());
    }
    public static string ToPositionString(Vertex vertex)
    {
        string result = $"v {Strings.FloatString(vertex.Position.X)} {Strings.FloatString(vertex.Position.Y)} {Strings.FloatString(vertex.Position.Z)}";
        if(vertex.Position.W != 0) result += $" {Strings.FloatString(vertex.Position.W)}";
        if(vertex.Color != null && !Colors.IsWhite(vertex.Color.Value)) result += $" {Strings.FloatString(vertex.Color.Value.R/255.0f)} {vertex.Color.Value.G/255.0f} {vertex.Color.Value.B/255.0f}";
        return result;
    }
    public static string ToUVString(Vertex vertex)
    {
        if(!vertex.UV.HasValue) throw new Exception("no texture coords");
        float x = vertex.UV.Value.X;
        float y = vertex.UV.Value.Y;
        string result = $"vt {Strings.FloatString(x)} {Strings.FloatString(y)}";
        //if(vertex.UV.Value.Z != 0 || !float.IsNaN(vertex.UV.Value.Z)) result += $" {Strings.FloatString(vertex.UV.Value.Z)}";
        return result;
    }
    public static string ToNormalString(Vertex vertex)
    {
        if(!vertex.Normal.HasValue) throw new Exception("no normal");
        float length = vertex.Normal.Value.LengthSquared();
        float x = vertex.Normal.Value.X/length;
        float y = vertex.Normal.Value.Y/length;
        float z = vertex.Normal.Value.Z/length;
        return $"vn {Strings.FloatString(x)} {Strings.FloatString(y)} {Strings.FloatString(z)}";
    }
    public static string ToFaceString(Face face)
    {
        // f vx vy vz
        // f vx/vtx vy/vty vz/vtz
        // f vx/vtx/vnx vy/vty/vny vz/vtz/vnz
        // t vx//vnx vy//vny vz//vnz
        static string Format(int vertex,int? textureCoords,int? normal)
        {
            string result = $"{vertex+1}";
            if(textureCoords != null) result += $"/{textureCoords+1}";
            if(normal != null) result += (textureCoords == null ? '/' : string.Empty) + $"/{normal+1}";
            return result;
        }
        return $"f {Format(face.X,face.UVX,face.NX)} {Format(face.Y,face.UVY,face.NY)} {Format(face.Z,face.UVZ,face.NZ)}";
    }
    
}